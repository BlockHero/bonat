<!doctype html>

<html lang="en">  
<head>  
<meta charset="utf-8" />  
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />  
<title>I het, I het but I lab u</title>  
<style>  
:root{  
  --ui-bg: rgba(0,0,0,0.34);  
  --accent: #ff6b6b;  
  --hud-font: system-ui,Segoe UI,Roboto,Arial;  
}  
*{box-sizing:border-box; -webkit-tap-highlight-color:transparent;}  
html,body{height:100%; margin:0; background:#07101a; font-family:var(--hud-font); -webkit-user-select:none; user-select:none;}  
#gameWrap{position:relative; width:100%; height:100vh; overflow:hidden; touch-action:none;}  
canvas#game{display:block; width:100%; height:100%; background:linear-gradient(#87c0ff,#7bb7ff);}  /* Minimap */
#minimap{position:absolute; right:12px; top:12px; width:120px; height:120px; background:rgba(0,0,0,0.45); border-radius:8px; z-index:120; overflow:hidden; border:2px solid rgba(255,255,255,0.06);}

/* Joystick */
#joystickArea{position:absolute; left:12px; bottom:12px; width:150px; height:150px; z-index:110; touch-action:none;}
.joystick-bg{position:absolute; inset:0; border-radius:50%; background:var(--ui-bg); display:flex; align-items:center; justify-content:center; pointer-events:none;}
#stick{position:absolute; width:66px; height:66px; left:42px; top:42px; border-radius:50%; background:rgba(255,255,255,0.96); box-shadow:0 8px 18px rgba(0,0,0,0.45); transition:transform 0.02s linear;}

/* Button utilities */
.ui-btn{background:var(--ui-bg); color:#fff; border-radius:12px; border:1px solid rgba(255,255,255,0.06); pointer-events:auto; padding:6px;}
.ui-btn.circle{width:70px; height:70px; border-radius:50%; font-size:22px; display:inline-flex; align-items:center; justify-content:center;}
.ui-btn.small{width:70px;height:70px}

/* Buttons */
#pauseBtn{position:absolute; left:50%; transform:translateX(-50%); top:12px; z-index:120;}
#restartBtn{
  position:absolute;
  right:237px; /* adjust if needed */
  top:12px;
  z-index:110;
}
#fsBtn{position:absolute; left:60%; transform:translateX(-50%); top:12px; z-index:120;}
#sprintBtn{position:absolute; right:20px; bottom:40px; z-index:110;}
#endBtn{
  position:absolute;
  left:10px;   /* adjust if needed */
  bottom:400px;
  z-index:110;
}
@keyframes pulseGlow{
  0%{
    transform:scale(1);
    box-shadow:
      0 0 4px rgba(255,180,220,.6),
      0 0 8px rgba(255,150,210,.4);
  }
  50%{
    transform:scale(1.08);
    box-shadow:
      0 0 10px rgba(255,180,220,.9),
      0 0 18px rgba(255,150,210,.6),
      0 0 26px rgba(255,120,200,.4);
  }
  100%{
    transform:scale(1);
    box-shadow:
      0 0 4px rgba(255,180,220,.6),
      0 0 8px rgba(255,150,210,.4);
  }
}

#endBtn{
  animation:pulseGlow 2.4s ease-in-out infinite;
}
#okBtn{
  position:absolute;
  right:20px;
  bottom:140px;
  z-index:110;
}

#hiBtn{
  position:absolute;
  right:100px;
  bottom:90px;
  z-index:110;
}

/* Pause overlay */
#pauseOverlay{position:absolute; inset:0; background:rgba(0,0,0,0.55); display:none; z-index:200; align-items:center; justify-content:center; color:#fff; font-size:20px;}
#pauseOverlay .box{background:rgba(0,0,0,0.6); padding:18px; border-radius:12px; border:1px solid rgba(255,255,255,0.06); text-align:center;}
#mapPopup{position:fixed; inset:0; display:none; z-index:9999; align-items:center; justify-content:center; background:rgba(0,0,0,0.8);}
#bigMap{background:#222; border:3px solid white; width:300px; height:300px;}

@media(min-width:900px){
#joystickArea{left:24px; bottom:24px; width:180px; height:180px;}
#stick{width:80px; height:80px; left:50px; top:50px;}
}

#dialogueBox {
position: absolute;
top: 200px;
left: 50%;
transform: translateX(-50%);
max-width: 80%;
min-width: 280px;
padding: 18px 22px;
background: linear-gradient(145deg, #ffd4d4, #ffe8d4);
color: #333;
font-size: 16px;
font-family: 'Segoe UI', system-ui, sans-serif;
border-radius: 24px;
box-shadow: 0 8px 24px rgba(0,0,0,0.25);
border: 2px solid #ff6b6b;
opacity: 0;
pointer-events: none;
transition: opacity 0.25s ease;
z-index: 160;
text-align: center;
position: absolute;
line-height: 1.4;
}
#dialogueBox.show {
  opacity: 1;
  pointer-events: auto;
}
#dialogueTail {
position: absolute;
bottom: -16px; /* farther down for soft look */
left: 50%;
transform: translateX(-50%) rotate(45deg);
width: 28px;
height: 28px;
background: linear-gradient(145deg, #ffd4d4, #ffe8d4);
border-left: 2px solid #ff6b6b;
border-bottom: 2px solid #ff6b6b;
border-radius: 6px;
}

.win98{
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  width:360px;

  background:#ffe9f2;
  border:2px solid #d88fb2;
  border-radius:0;

  box-shadow:
    0 6px 18px rgba(216,143,178,0.35),
    inset 2px 2px 0 #fff,
    inset -2px -2px 0 #e2a2be;

  font-family: "MS Sans Serif", system-ui;
  z-index:200;
}

.win98.top{
  z-index:210;
}

/* HEADER */
.win98-header{
  background:#f4b1cf;
  color:#3b1d2a;
  padding:6px 8px;
  display:flex;
  justify-content:space-between;
  align-items:center;
  font-size:14px;

  border-bottom:2px solid #d88fb2;
}

/* BODY */
.win98-body{
  padding:14px;
  background:#fff2f7;
  color:#4a2233;
  font-size:13px;
  line-height:1.45;
}

/* BUTTON */
.win98-btn{
  margin-top:12px;
  padding:6px 16px;
  background:#ffe0ec;
  border:2px solid #d88fb2;
  border-radius:0;
  cursor:pointer;

  font-size:13px;
  color:#4a2233;

  box-shadow:
    inset 1px 1px 0 #fff,
    inset -1px -1px 0 #c9799f;
}

.win98-btn:hover{
  background:#ffd6e6;
}

.win98-btn:active{
  box-shadow:
    inset -1px -1px 0 #fff,
    inset 1px 1px 0 #c9799f;
}

/* video container */
.video-wrap{
  width: 320px;           /* popup width */
  height: 320px;          /* popup height */
  display: flex;
  align-items: center;
  justify-content: center;
  background: #000;
  border-radius: 8px;
  overflow: hidden;
}

/* auto-scale video */
.video-wrap video{
  width: 100%;
  height: 100%;
  object-fit: contain;   /* üîë this is the magic */
}

/* CLOSE BUTTON */
.close-btn{
  width:20px;
  height:20px;
  background:#ffe0ec;
  border:2px solid #d88fb2;
  border-radius:0;
  font-size:12px;
  cursor:pointer;
  color:#4a2233;
  line-height:14px;
}
.close-btn:hover{
  background:#ffd6e6;
}
.close-btn:active{
  box-shadow:
    inset -1px -1px 0 #fff,
    inset 1px 1px 0 #c9799f;
}

.hidden{
  display:none;
}

#openingScreen {
  position: fixed;
  inset: 0;
  background: rgba(255, 240, 250, 0.95);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

#openingScreen .popup {
  background: #ffe0f0;
  border: 2px solid #ff6b6b;
  border-radius: 24px;
  padding: 30px 40px;
  text-align: center;
  box-shadow: 0 8px 24px rgba(255, 150, 200, 0.35);
  animation: popupBounce 0.6s ease;
}

#openingScreen h2 {
  margin-bottom: 12px;
  font-size: 28px;
  color: #ff6b6b;
}

#openingScreen p {
  margin-bottom: 20px;
  font-size: 16px;
  color: #333;
}

@keyframes popupBounce {
  0% { transform: scale(0.8); opacity: 0; }
  60% { transform: scale(1.05); opacity: 1; }
  100% { transform: scale(1); }
}
#eventImg{
  width: 260px;
  height: 260px;
  max-width: none;
  max-height: none;

  object-fit: cover;       /* fills square nicely */
  border-radius: 12px;     /* NOT 50% */
  background: #fff;

  display: block;
}
</style>

</head>  
<body>  
<div id="gameWrap">  
    <div id="openingScreen">
  <div class="popup">
    <h2>You came...</h2>
    <p>Now open it w your fingerprints</p>
    <p>touch it like how you would touch me</p>
    <button id="startGameBtn" class="ui-btn circle">ü´Ü</button>
  </div>
</div>
  <canvas id="game"></canvas>    <!-- Dialogue Box -->  <div id="dialogueBox">  
  <div id="dialogueText"></div>  
  <div id="dialogueTail"></div> <!-- speech bubble tail -->  
</div>    <!-- Minimap -->  <canvas id="minimap"></canvas>

  <div id="mapPopup"><canvas id="bigMap"></canvas></div>    <!-- Joystick -->    <div id="joystickArea" aria-hidden="true">  
    <div class="joystick-bg"></div>  
    <div id="stick"></div>  
  </div>    <!-- Buttons -->  <button id="pauseBtn" class="ui-btn">‚è∏Ô∏è</button>
  <button id="restartBtn" class="ui-btn">üîÑ</button>
<button id="fsBtn" class="ui-btn">üî≤</button>
<button id="endBtn" class="ui-btn circle">üíå</button>
<button id="sprintBtn" class="ui-btn circle">üèÉ</button>
<button id="okBtn" class="ui-btn circle">üò°</button>
<button id="hiBtn" class="ui-btn circle">ü§¨</button>

<div id="eventOverlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.7);align-items:center;justify-content:center;z-index:9999;">
  <img id="eventImg" style="max-width:80%;max-height:80%;border:3px solid white;border-radius:12px;">
</div>

  <!-- Pause overlay -->    <div id="pauseOverlay"><div class="box"><div style="font-weight:700;margin-bottom:8px">PAUSED</div>  
  <div>Tap resume to continue</div><div style="height:12px"></div><button id="resumeBtn" class="ui-btn">RESUME</button></div></div>  
</div>  

<div id="endingPopup" class="win98 hidden">
  <div class="win98-header">
    <span>Labyu</span>
    <button class="close-btn" onclick="closeEndingPopup()">‚úï</button>
  </div>
  <div class="win98-body">
    <p>Happy 18th Monthversary to my only baby who I adore, even though with bad mood sometimes too, ik we both are sometimes too toxic and hurt eachother but I'm still glad to have you.</p>
    <p>I hope we overcome all problems we face along this hard ahh ldr journey, I mean yeah we don't know if we will marry eachother or no but what matters is that we hope and pray and work hard towards making it true instead of leaving it all on destiny, if u just wanna go w flow then go marry flow tf.
ok.</p>
<p>I hope we stay together forever and someday meet, may that come soon af but until then I'll deal w your bullshit, you gotta deal w my bullshit too. But most importantly I love you. woahh last 2 lines rhymed hahshs. Open dat shi down there now</p>
<p>- A small gift from your Nayan</p>
    <button class="win98-btn" onclick="openVideoPopup()">Open</button>
  </div>
</div>

<div id="videoPopup" class="win98 hidden top">
  <div class="win98-header">
    <span>Surprise</span>
    <button class="close-btn" onclick="closeVideoPopup()">‚úï</button>
  </div>
  <div class="win98-body">
    <div class="video-wrap">
  <video
    id="endingVideo"
    controls
    playsinline
  >
    <source src="18th.mp4" type="video/mp4">
  </video>
</div>
  </div>
</div>

<audio id="bgMusic" loop>
  <source src="18thmusic.mp3" type="audio/mpeg">
</audio>

<script>  
let moveTouchId = null;  
let activeDialogueTile = null;
let endingPopupActive = false;  
let activeEventTile = null;

const dialogueBox = document.getElementById("dialogueBox");  
const dialogueText = document.getElementById("dialogueText");  

function showDialogue(text){
  dialogueText.textContent = text;
  dialogueBox.classList.add("show");

  // auto close after a short time (optional but nice)
  clearTimeout(showDialogue._t);
  showDialogue._t = setTimeout(() => {
    dialogueBox.classList.remove("show");
  }, 1800);
}
/* -------------------------------------------------------------------  
   Config & small helpers (merged and centralized)  
   ------------------------------------------------------------------- */  
const TILE = 60, MAP_W = 60, MAP_H = 60;  
const PLAYER_RADIUS = 18, SPRINT_MULT = 2.0, STICK_RADIUS = 56;
const SAVE_KEY = "gift_game_completed_v1";  
  
const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');  
const mini = document.getElementById('minimap'), mctx = mini.getContext('2d');  

document.getElementById("minimap").style.display = "none";

CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
  this.beginPath();
  this.moveTo(x + r, y);
  this.arcTo(x + w, y, x + w, y + h, r);
  this.arcTo(x + w, y + h, x, y + h, r);
  this.arcTo(x, y + h, x, y, r);
  this.arcTo(x, y, x + w, y, r);
  this.closePath();
  return this;
};
  
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }  
function approach(a,b,delta){ return a<b ? Math.min(b,a+delta) : Math.max(b,a-delta); }  
function centerOf(tx,ty){ return { x: tx*TILE + TILE/2, y: ty*TILE + TILE/2 }; }  
function moveTowards(obj, tx, ty, speed, dt){  
  const dx = tx - obj.x, dy = ty - obj.y;  
  const dist = Math.hypot(dx,dy);  
  if (dist < 0.0001) return true;  
  obj.x += (dx/dist) * speed * dt;  
  obj.y += (dy/dist) * speed * dt;  
  return dist <= 1;  
}  
  
/* safeMove: single place for collision rollback */  
function safeMove(obj, dx, dy){  
  const nx = obj.x + dx, ny = obj.y + dy;  
  if (tileAt(nx, ny) === 'building' || tileAt(nx, ny) === 'water') {  
    return false;  
  } else {  
    obj.x = nx; obj.y = ny; return true;  
  }  
}  
  
/* bindHoldButton helper */  
function bindHoldButton(el, onDown, onUp){  
  el.addEventListener('touchstart', e => { if (e.cancelable) e.preventDefault(); onDown(); }, {passive:false});  
  el.addEventListener('touchend', e => { if (e.cancelable) e.preventDefault(); onUp(); }, {passive:false});  
  el.addEventListener('mousedown', onDown);  
  window.addEventListener('mouseup', onUp);  
}  
  
/* -------------------------------------------------------------------  
   Resize / DPR  
   ------------------------------------------------------------------- */  
function resize(){  
  const dpr = Math.min(window.devicePixelRatio || 1, 2);  
  canvas.width = Math.floor(window.innerWidth * dpr);  
  canvas.height = Math.floor(window.innerHeight * dpr);  
  canvas.style.width = window.innerWidth + 'px';  
  canvas.style.height = window.innerHeight + 'px';  
  ctx.setTransform(dpr,0,0,dpr,0,0);  
  
  mini.width = 120 * dpr; mini.height = 120 * dpr;  
  mini.style.width = '120px'; mini.style.height = '120px';  
  mctx.setTransform(dpr,0,0,dpr,0,0);  
}  
window.addEventListener('resize', resize); resize();  
  
/* -------------------------------------------------------------------  
   Map -> world  
   ------------------------------------------------------------------- */  
const tileTypes = { 0:'park', 1:'building', 2:'road', 3:'water' };  
  
// Permanent 60x60 map (example city layout)  
const map = new Uint8Array([
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,0,0,0,0,0,0,0,0,0,0,2,2,1,3,3,3,3,3,3,3,3,3,3,3,1,1,2,1,1,3,3,3,3,3,3,3,3,3,3,3,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,1, 1,0,0,0,0,0,0,0,0,0,0,2,2,1,3,1,1,3,3,3,3,3,1,1,3,1,1,2,1,1,3,1,1,3,3,3,3,3,1,1,3,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,1, 1,0,1,0,1,0,1,0,1,0,1,0,0,1,3,1,1,1,3,3,3,1,1,1,3,1,0,0,0,1,3,1,1,1,3,3,3,1,1,1,3,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,1, 1,1,1,1,1,1,1,1,1,1,1,0,0,1,3,1,1,1,1,3,1,1,1,1,3,1,0,0,0,1,3,1,1,1,1,3,1,1,1,1,3,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,
1,3,1,2,2,2,2,2,2,2,1,0,0,1,3,1,1,1,1,1,1,1,1,1,3,1,0,0,0,1,3,1,1,1,1,1,1,1,1,1,3,1,0,0,1,3,3,3,3,3,3,3,3,3,3,3,1,0,0,1, 1,3,1,2,0,2,2,2,0,2,1,0,0,1,3,1,1,1,1,1,1,1,1,1,3,1,0,0,0,1,3,1,1,1,1,1,1,1,1,1,3,1,0,0,1,1,1,1,3,3,3,1,1,3,3,1,1,0,0,1, 1,3,1,2,2,2,2,2,2,2,1,0,0,1,3,3,1,1,1,1,1,1,1,3,3,1,0,0,0,1,3,3,1,1,1,1,1,1,1,3,3,1,0,0,1,1,3,1,3,3,3,1,1,1,3,1,1,0,0,1, 1,3,1,2,2,2,2,2,2,2,1,0,0,1,3,3,3,1,1,1,1,1,3,3,3,1,0,0,0,1,3,3,3,1,1,1,1,1,3,3,3,1,0,0,1,1,1,1,3,1,3,1,3,1,1,1,1,0,0,1, 1,3,1,2,0,2,2,2,2,2,1,0,0,1,3,3,3,3,1,1,1,3,3,3,3,1,0,0,0,1,3,3,3,3,1,1,1,3,3,3,3,1,0,0,1,1,3,1,3,3,3,1,3,3,1,1,1,0,0,1,
1,3,1,2,2,2,2,2,2,2,1,0,0,1,3,3,3,3,3,1,3,3,3,3,3,1,0,0,0,1,3,3,3,3,3,1,3,3,3,3,3,1,0,0,1,3,3,3,3,3,3,3,3,3,3,3,1,0,0,1, 1,3,1,2,2,2,2,2,2,2,1,0,0,1,3,3,3,3,3,3,3,3,3,3,3,1,0,0,0,1,3,3,3,3,3,3,3,3,3,3,3,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1, 1,3,1,2,0,2,2,0,2,2,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0,2,2,0,0,0,2,2,0,0,0,0,2,2,1, 1,3,1,2,2,2,2,2,2,2,0,2,2,0,0,0,0,0,0,0,0,1,3,3,3,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0,2,2,0,0,0,2,2,0,0,0,0,2,2,1, 1,3,1,2,2,2,2,2,2,2,0,2,2,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,1,3,3,3,3,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,1,0,1,0,0,1,
1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,0,1,3,3,3,2,0,0,0,1,3,1,1,3,1,0,0,1,3,3,3,3,3,3,3,1,0,0,1,3,1,0,0,1,0,1,1,0,0,1, 1,1,3,3,3,3,3,1,0,0,1,3,3,3,3,3,3,1,0,0,0,2,2,2,2,2,0,0,0,1,3,1,1,3,1,0,0,1,3,3,3,3,3,3,3,1,0,0,1,3,1,2,2,0,0,0,0,2,2,1, 1,1,3,3,3,3,3,1,0,0,1,3,3,3,3,3,3,1,0,0,0,1,3,3,3,1,0,0,0,1,3,1,1,3,1,0,0,1,3,3,1,1,1,1,1,1,0,0,1,3,1,2,2,0,0,0,0,2,2,1, 1,1,3,3,3,3,3,1,0,0,1,3,3,3,3,3,3,1,0,0,0,2,2,2,2,2,0,0,0,1,3,1,1,3,1,0,0,1,3,3,1,2,2,0,0,0,2,2,1,3,1,1,1,1,1,1,1,0,0,1, 1,1,3,3,3,3,3,1,0,0,1,3,3,3,3,3,3,1,0,0,0,2,3,3,3,2,0,0,0,1,3,1,1,3,1,0,0,1,3,3,1,2,2,0,0,0,2,2,1,3,3,3,3,3,3,1,1,0,0,1,
1,1,3,3,3,3,3,1,0,0,1,3,3,3,3,3,3,1,0,0,0,2,2,2,2,2,0,0,0,1,3,1,1,3,1,0,0,1,3,3,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1, 1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,0,1,3,3,3,1,0,0,0,1,3,1,1,3,1,0,0,1,1,1,1,0,0,1,3,3,3,3,3,3,3,3,3,3,3,1,1,0,0,1, 1,1,2,2,0,0,0,0,2,2,0,0,0,0,2,2,1,1,0,0,0,2,2,3,3,1,0,0,0,1,3,1,1,3,1,2,2,0,0,0,0,2,2,1,3,3,1,3,3,3,1,1,1,1,3,1,0,0,0,1, 1,1,2,2,0,0,0,0,2,2,0,0,0,0,2,2,1,1,0,0,0,1,3,2,2,2,0,0,0,1,3,1,1,3,1,2,2,0,0,0,0,2,2,1,3,1,1,3,3,3,1,3,3,1,3,1,1,0,0,1, 1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,2,2,3,3,1,0,0,0,1,3,1,1,3,1,0,0,1,1,1,1,0,0,1,3,3,1,3,3,3,1,3,3,1,3,1,0,0,0,1,
1,1,0,0,1,3,3,3,3,3,3,3,3,1,0,0,0,1,0,0,0,1,3,3,3,1,0,0,0,1,3,1,1,3,1,0,0,1,3,3,1,0,0,1,3,3,1,3,3,3,1,1,1,1,3,1,1,0,0,1, 1,1,0,0,1,3,3,3,3,3,3,3,3,1,0,0,1,1,0,0,0,1,3,3,3,1,0,0,0,1,3,1,1,3,1,0,0,1,3,3,1,0,0,1,3,3,1,3,3,3,1,3,3,1,3,1,0,0,0,1, 1,1,0,0,1,3,3,3,3,3,3,3,3,1,0,0,1,1,0,0,0,2,3,2,3,2,0,0,0,1,3,1,1,3,1,0,0,1,1,1,1,0,0,1,3,3,1,3,3,3,1,3,3,1,3,1,1,0,0,1, 1,0,0,0,1,3,3,3,3,3,3,3,3,1,0,0,1,1,0,0,0,2,2,2,2,2,0,0,0,1,3,1,1,3,1,2,2,0,0,0,0,2,2,1,3,1,1,1,3,3,1,1,1,1,3,1,0,0,0,1, 1,1,0,0,1,3,3,3,3,3,3,3,3,1,0,0,1,1,0,0,0,1,3,3,3,1,0,0,0,1,3,1,1,3,1,2,2,0,0,0,0,2,2,1,3,3,3,3,3,3,3,3,3,3,3,1,0,0,0,1,
1,1,0,0,1,3,3,3,3,3,3,3,3,1,0,0,0,1,0,0,0,2,2,2,2,1,0,0,0,1,3,1,1,3,1,2,2,0,0,0,0,2,2,1,3,3,3,3,3,3,3,3,3,3,3,1,0,0,0,1, 1,1,0,0,1,1,1,1,1,1,1,1,3,1,0,0,1,1,0,0,0,1,3,3,2,2,0,0,0,1,3,3,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,1, 1,1,0,0,1,2,2,0,0,2,2,1,3,1,0,0,1,1,0,0,0,2,2,2,2,1,0,0,0,1,3,3,3,3,3,3,3,3,1,1,1,1,3,1,1,1,1,3,1,3,3,3,1,3,3,1,0,0,2,1, 1,0,0,0,1,2,2,0,0,2,2,1,3,1,0,0,1,1,0,0,0,1,3,3,3,1,0,0,0,1,3,1,1,3,3,3,3,3,1,3,3,3,3,1,3,3,3,3,3,1,3,1,3,3,3,1,0,2,2,1, 1,1,0,0,1,0,0,1,1,0,0,1,3,1,0,0,1,1,0,0,0,2,2,2,2,2,0,0,0,1,3,3,1,1,1,3,3,3,1,1,1,1,3,1,1,1,1,3,3,3,1,3,3,3,3,1,2,2,0,1,
1,1,0,0,1,0,0,1,1,0,0,1,3,1,0,0,0,1,0,0,0,2,3,3,3,2,0,0,0,1,3,1,1,3,3,3,3,3,3,3,3,1,3,1,3,3,3,3,3,1,3,1,3,3,3,1,2,0,0,1, 1,1,0,0,1,0,0,0,1,0,0,1,3,1,0,0,1,1,0,0,0,2,2,2,2,2,0,0,0,1,3,3,3,3,3,3,3,3,1,1,1,1,3,1,1,1,1,3,1,3,3,3,1,3,3,1,2,0,0,1, 1,1,0,0,1,0,0,1,1,0,0,1,3,1,0,0,1,1,0,0,0,1,3,3,3,1,0,0,0,1,3,3,3,3,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1, 1,1,0,0,1,0,0,1,0,0,0,1,3,1,0,0,1,1,0,0,0,1,3,3,3,2,0,0,0,1,3,1,1,1,1,3,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,1, 1,0,0,0,1,0,0,1,1,0,0,1,3,1,0,0,0,1,0,0,0,2,2,2,2,2,0,0,0,1,3,3,3,3,3,3,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
1,1,0,0,1,0,0,0,1,0,0,1,3,1,0,0,1,1,0,0,0,1,3,3,3,1,0,0,0,1,3,3,3,3,1,3,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1, 1,1,0,0,1,0,0,1,1,0,0,1,3,1,0,0,1,1,0,0,0,1,3,3,3,1,0,0,0,1,3,1,1,1,1,3,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,3,3,3,1,0,0,0,1, 1,1,2,2,0,2,2,1,1,0,0,1,3,1,0,0,1,1,0,0,0,2,2,2,2,2,0,0,0,1,3,3,3,3,3,3,1,0,0,1,3,3,1,2,2,0,0,0,0,2,2,1,3,3,3,1,0,0,0,1, 1,1,2,2,0,2,2,1,1,0,0,1,1,1,1,1,1,1,0,0,0,1,3,3,3,1,0,0,0,1,3,1,1,1,1,3,1,0,0,1,3,3,1,2,2,0,0,0,0,2,2,1,3,3,3,1,0,0,0,1, 1,1,1,1,1,1,1,1,1,0,0,1,3,3,3,3,3,1,0,0,0,1,3,3,3,1,0,0,0,1,3,1,3,1,3,3,1,0,0,1,3,3,1,0,0,1,0,0,1,0,0,1,3,3,3,1,0,0,0,1,
1,3,3,3,3,3,3,3,1,0,0,1,3,3,3,3,3,1,0,0,0,1,1,1,1,1,0,0,0,1,3,1,1,1,1,3,1,0,0,1,3,3,1,0,0,1,1,1,1,0,0,1,3,3,3,1,0,0,0,1, 1,3,3,3,3,3,3,3,1,0,0,1,3,3,3,3,3,1,2,2,2,0,0,0,0,0,2,2,2,1,3,3,3,3,3,3,1,0,0,1,3,3,1,0,0,1,1,2,0,2,2,1,3,3,3,1,0,0,0,1, 1,3,3,3,3,3,3,3,1,0,0,1,3,3,3,3,3,1,2,2,2,0,0,0,0,0,2,2,2,1,1,1,1,1,1,1,1,0,0,1,3,3,1,0,0,1,1,2,0,2,2,1,3,3,3,1,0,0,0,1, 1,3,3,3,3,3,3,3,1,0,0,1,3,3,3,3,3,1,2,2,2,0,0,0,0,0,2,2,2,0,2,2,0,0,0,0,0,2,2,1,3,3,1,0,0,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1, 1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0,0,0,0,2,2,1,3,3,1,0,0,1,0,0,1,3,3,3,3,3,3,1,0,0,0,1,
1,2,2,0,0,0,0,0,0,2,2,0,0,0,2,2,1,3,3,3,3,3,3,3,3,3,3,3,3,1,0,0,1,1,1,1,1,0,0,1,3,3,1,0,0,1,1,0,1,3,3,3,3,3,3,1,0,0,0,1, 1,2,2,0,0,0,0,0,0,2,2,0,0,0,2,2,1,3,3,3,3,3,3,3,3,3,3,3,3,1,0,0,1,3,3,3,1,0,0,1,3,3,1,0,0,1,1,0,1,3,3,3,3,3,3,1,0,0,0,1, 1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,3,3,3,3,3,3,3,3,3,3,3,3,1,0,0,1,1,1,1,1,0,0,1,3,3,1,0,0,1,0,0,1,3,3,3,3,3,3,1,0,0,0,1, 1,0,0,1,3,3,3,3,3,3,3,3,3,1,0,0,1,1,1,1,1,1,1,1,1,1,1,3,3,1,2,2,0,0,0,0,0,2,2,1,3,3,1,0,0,1,1,0,1,3,3,3,3,3,3,1,0,0,0,1, 1,0,0,1,3,3,3,3,3,3,3,3,3,1,2,2,0,0,0,0,0,0,0,0,2,2,1,3,3,1,2,2,0,0,0,0,0,2,2,1,3,3,1,0,0,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,
1,0,0,1,3,3,3,3,3,3,3,3,3,1,2,2,0,0,0,0,0,0,0,0,2,2,1,3,3,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,2,0,0,0,0,0,0,0,0,2,2,2,1, 1,0,0,1,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,3,3,3,3,3,3,3,3,3,1,0,0,1,1,2,0,0,0,0,0,0,0,0,2,2,2,1, 1,0,0,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,2,2,0,0,0,0,2,2,1,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,2,2,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,2,2,0,0,0,0,2,2,1,3,3,3,3,3,3,3,3,3,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1, 1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1

]);  
  
const world = [];  
for(let y=0;y<TILE;y++){  
  world[y]=[];  
  for(let x=0;x<TILE;x++){  
    const t = map[y*TILE + x];  
    world[y][x] = tileTypes[t] || 'park';  
  }  
}  
window.dispatchEvent(new Event("worldReady"));  
  
function tileAt(px,py){  
  const tx = Math.floor(px / TILE), ty = Math.floor(py / TILE);  
  if (tx<0||ty<0||tx>=MAP_W||ty>=MAP_H) return 'water';  
  return world[ty][tx];  
}  
  
  
// ================= DIALOGUE TILE TRIGGERS =================  
const dialogueZones = [  
  {  
    tiles: [  
      [1,58],[2,58]
    ],  
    text: "Hello baby"  
  },
    {  
    tiles: [  
      [1,54],[2,54]
    ],  
    text: "You gotta collect 5 keys to unlock *spoiler*"  
  },
  {  
    tiles: [  
      [1,50],[2,50],[1,51],[2,51]
    ],  
    text: "Did u notice the cat tho"  
  },
  {  
    tiles: [  
      [7,50],[7,51]
    ],  
    text: "cat jumps around u if don't move for few seconds"  
  },
  {  
    tiles: [  
      [9,42],[10,42]
    ],  
    text: "You love cursing so I gave you special buttons"  
  },
  {  
    tiles: [  
      [3,38],[2,38]
    ],  
    text: "Yeah I see u looking for them keys"  
  },
  {  
    tiles: [  
      [2,36],[3,36]
    ],  
    text: "Keys are in my pants üòÇ"  
  },
  {  
    tiles: [  
      [2,22],[3,22],[2,23],[3,23]
    ],  
    text: "You can even make game full screen if u accidentally made it clipped."  
  },
  {  
    tiles: [  
      [26,4],[27,4],[28,4]
    ],  
    text: "Door is locked eh?"  
  },
  {  
    tiles: [  
      [26,3],[27,3],[28,3]
    ],  
    text: "You need 5 keys first to unlock it."  
  },
  {  
    tiles: [  
      [26,12],[27,12],[28,12]
    ],  
    text: "Go back"  
  },
  {  
    tiles: [  
      [29,48],[30,48],[31,48],
      [30,49],[31,49]
    ],  
    text: "walk down here if u wanna waste your time"  
  },
  {  
    tiles: [  
      [27,1]
    ],  
    text: "wow baby u actually did it, click on map too for more."  
  },
  {  
    tiles: [  
      [7,12]
    ],  
    text: "stand on green tile on left of this one."  
  },
  {  
    tiles: [  
      [4,12]
    ],  
    text: "I meant the the one on top"  
  },
  {  
    tiles: [  
      [4,9]
    ],  
    text: "no the other top."  
  },
  {  
    tiles: [  
      [4,6]
    ],  
    text: "Good girl, so obedient."  
  },
  {  
    tiles: [  
      [8,6]
    ],  
    text: "hahshshs"  
  },
  {  
    tiles: [  
      [58,56]
    ],  
    text: "I love you even though I hate you sometimes"  
  },
  {  
    tiles: [  
      [35,14],[36,14],[35,15],[36,15]
    ],  
    text: "suck my dick"  
  },
  {  
    tiles: [  
      [42,1]
    ],  
    text: "Yk I actually spent lot of time on this and if u don't appreciate it, u better consider it your last monthly gift."  
  }
];  
  
/* Entities: */  
const player = {   
  x:100,   
  y:3590,   
  r: PLAYER_RADIUS,   
  speed:200,   
  runMult:1.8,     
  lookX: 1,   
  lookY: 0,  
  
  // ‚îÄ‚îÄ spawn animation ‚îÄ‚îÄ  
  spawning: true,  
  spawnTimer: 0,  
  spawnDuration: 0.6,  
  spawnShake: 6,  
  spawnFlickerRate: 40  
};  
  
  const cat = {
  x: player.x - 40,
  y: player.y + 26,
  r: 6,

  baseSpeed: 90,
  maxSpeed: 220,

  angle: 0,
  circling: false
};

const keys = []; // all keys in the world
const maxKeys = 5; // total number of keys to collect

const lockedTiles = [
  { x: 27, y: 2, requiredKeys: maxKeys, opened: false } // example tile
];

const eventTiles = [
  { x: 43, y: 54, type: 'image', data: '18img1.jpg' },
  { x: 44, y: 54, type: 'image', data: '18img1.jpg' },
  { x: 43, y: 56, type: 'image', data: '18img2.jpg' },
  { x: 44, y: 56, type: 'image', data: '18img2.jpg' },
  { x: 23, y: 40, type: 'sound', data: 'assets/sfx.mp3' },
];

// helper to check if a tile has an event
function eventTileAt(tx,ty){
  return eventTiles.some(e => e.x === tx && e.y === ty);
}

const endingTile = {
  x: 27,
  y: 0, // directly behind the locked tile
  triggered: false
};

let camX = player.x;  
let camY = player.y;  
const CAMERA_SPEED = 5.0; // higher = snappier, lower = smoother  
let idleTimer = 0;
const IDLE_TIME = 5; // seconds before cat starts circling

  
/* -------------------------------------------------------------------  
   Input & UI refs  
   ------------------------------------------------------------------- */  
const stick = document.getElementById('stick'), joystickArea = document.getElementById('joystickArea');  
const pauseBtn = document.getElementById('pauseBtn'), pauseOverlay = document.getElementById('pauseOverlay'), resumeBtn = document.getElementById('resumeBtn'); 
const mapPopup = document.getElementById('mapPopup'), bigMapCanvas = document.getElementById('bigMap'), bctx = bigMapCanvas.getContext('2d');  

const restartBtn = document.getElementById("restartBtn");
const endBtn = document.getElementById("endBtn");

// hide by default
restartBtn.style.display = "none";
endBtn.style.display = "none";

restartBtn.onclick = restartGameSoft;

// ===== LOAD SAVE =====
const savedCompleted = localStorage.getItem(SAVE_KEY) === "true";
if (savedCompleted) {
  restartBtn.style.display = "block";
  endBtn.style.display = "flex"; // circle button needs flex
}

if (savedCompleted) {
  // open all locks
  for (const lt of lockedTiles) {
    lt.opened = true;
  }
}

endBtn.addEventListener("click", () => {
  openEndingPopup();
  endingPopupActive = true; // prevents tile auto-reopen spam
});
  
let input = { moveX:0, moveY:0 }, joy = { x:0, y:0, activeId:null }, STICK_R = STICK_RADIUS;  
let inputKeys = {}; window.addEventListener('keydown', e => inputKeys[e.key.toLowerCase()] = true); window.addEventListener('keyup', e => inputKeys[e.key.toLowerCase()] = false);  
  
/* joystick logic (keeps as-is but uses helper positions) */  
function getRect(el){ return el.getBoundingClientRect(); }  
function startStick(x, y){  
  joy.active = true;  
  joy.startX = x;  
  joy.startY = y;  
  moveStick(x, y);  
}  
  
function moveStick(x, y){  
  const rect = joystickArea.getBoundingClientRect();  
  let dx = x - joy.startX;  
  let dy = y - joy.startY;  
  
  const max = 40;  
  const d = Math.hypot(dx, dy);  
  if (d > max){  
    dx = dx / d * max;  
    dy = dy / d * max;  
  }  
  
  joy.x = dx;  
  joy.y = dy;  
  
  input.moveX = dx / max;  
  input.moveY = dy / max;  
  
  stick.style.transform = `translate(${dx}px, ${dy}px)`;  
}  
  
function endStick(){  
  joy.active = false;  
  joy.x = joy.y = 0;  
  input.moveX = input.moveY = 0;  
  stick.style.transform = `translate(0px, 0px)`;  
}  
function handleStickMove(p){  
  const area = getRect(joystickArea);  
  const cx = area.left + area.width/2, cy = area.top + area.height/2;  
  let dx = p.clientX - cx, dy = p.clientY - cy;  
  const dist = Math.hypot(dx,dy);  
  if (dist > STICK_R){ dx = dx / dist * STICK_R; dy = dy / dist * STICK_R; }  
  stick.style.transform = `translate(${dx}px, ${dy}px)`;  
  joy.x = dx / STICK_R; joy.y = dy / STICK_R;  
  input.moveX = joy.x; input.moveY = joy.y;  
}  
joystickArea.addEventListener('touchstart', e=>{  
  if (moveTouchId !== null) return;  
  
  const t = e.changedTouches[0];  
  moveTouchId = t.identifier;  
  
  startStick(t.clientX, t.clientY);  
},{passive:false});  
  
joystickArea.addEventListener('touchmove', e=>{  
  for (const t of e.changedTouches){  
    if (t.identifier === moveTouchId){  
      moveStick(t.clientX, t.clientY);  
      break;  
    }  
  }  
},{passive:false});  
  
joystickArea.addEventListener('touchend', e=>{  
  for (const t of e.changedTouches){  
    if (t.identifier === moveTouchId){  
      moveTouchId = null;  
      endStick();  
      break;  
    }  
  }  
},{passive:false});  
  
joystickArea.addEventListener('mousedown', e=>{ startStick(e); window.addEventListener('mousemove', moveStick); });  
window.addEventListener('mouseup', e=>{ endStick(e); window.removeEventListener('mousemove', moveStick); });  
  
/* sprint helper */  
let sprinting=false;  
const sprintBtn = document.getElementById('sprintBtn');  
bindHoldButton(sprintBtn, ()=>sprinting=true, ()=>sprinting=false);  

const okBtn = document.getElementById('okBtn');
const hiBtn = document.getElementById('hiBtn');

bindHoldButton(
  okBtn,
  ()=> showDialogue("tankina"),
  ()=> {}
);

bindHoldButton(
  hiBtn,
  ()=> showDialogue("madarchod"),
  ()=> {}
);
  
   
  
window.addEventListener('keydown', e => {  
  if(e.key==='Shift') sprinting=true;  
  if(e.key==='p') togglePause();  
});  
  
window.addEventListener('keyup', e => { if(e.key==='Shift') sprinting=false; });  
  
/* pause handling */  
let paused=false;  
function setPaused(v){ paused=v; pauseOverlay.style.display = v ? 'flex' : 'none'; }  
function togglePause(){ setPaused(!paused); }  
pauseBtn.addEventListener('click', ()=> togglePause()); resumeBtn.addEventListener('click', ()=> setPaused(false));  
  
  
/* fullscreen */  
function toggleFullscreen(){
  const elem = document.documentElement;
  if (!document.fullscreenElement) {
    elem.requestFullscreen().catch(()=>{});
  } else {
    document.exitFullscreen();
  }
}

document.getElementById("fsBtn").addEventListener("click", toggleFullscreen);

const startBtn = document.getElementById("startGameBtn");

startBtn.addEventListener("click", () => {
  document.getElementById("openingScreen").style.display = "none";

 toggleFullscreen(); // ‚úÖ reuse same fullscreen logic

  const music = document.getElementById("bgMusic");
  if (music) music.play();
});
  
  
function spawnKey() {
  while(true){
    const tx = Math.floor(Math.random() * MAP_W);
    const ty = Math.floor(Math.random() * MAP_H);
    const tile = world[ty][tx];

    // only spawn on park or road, skip everything else
    if(tile !== 'park' && tile !== 'road') continue;
    if(eventTileAt(tx,ty)) continue;

    // okay to spawn key
    keys.push({ x: tx*TILE + TILE/2, y: ty*TILE + TILE/2, collected: false });
    break;
  }
}

// spawn all keys at game start
for(let i=0;i<maxKeys;i++) spawnKey();

// if already completed, mark all keys as collected
if (savedCompleted) {
  for (const k of keys) {
    k.collected = true;
  }
} 

function showeventimg(src){
  const overlay = document.getElementById('eventOverlay');
  const img = document.getElementById('eventImg');
  img.src = src;
  overlay.style.display = 'flex';
  overlay.onclick = ()=>overlay.style.display='none';
}
 
 function getCollectedKeyCount() {
  return keys.filter(k => k.collected).length;
}

function lockIsOpened(){
  return lockedTiles.every(t => t.opened);
}



function openEndingPopup(){
  document.getElementById("endingPopup").classList.remove("hidden");
}

function closeEndingPopup(){
  document.getElementById("endingPopup").classList.add("hidden");
}

function openVideoPopup(){
  const popup = document.getElementById("videoPopup");
  const video = document.getElementById("endingVideo");

  popup.classList.remove("hidden");

  if (video) {
    video.currentTime = 0;

    const p = video.play();
    if (p !== undefined) {
      p.catch(() => {}); // ‚úÖ silence AbortError safely
    }
  }
}

function closeVideoPopup(){
  const popup = document.getElementById("videoPopup");
  const video = document.getElementById("endingVideo");

  if (video) {
    video.pause();
    video.currentTime = 0;
  }

  popup.classList.add("hidden");
}


function restartGameSoft(){
  // ONLY allow if game was completed at least once
  const completed = localStorage.getItem(SAVE_KEY) === "true";
  if (!completed) return;

  // 1. Relock all locked tiles
  for (const lt of lockedTiles) {
    lt.opened = false;
  }

  // 2. Reset ending tile trigger
  endingTile.triggered = false;

  // 3. Reset keys
  for (const k of keys) {
    k.collected = false;
  }

  // 4. Respawn keys properly
  keys.length = 0;
  for (let i = 0; i < maxKeys; i++) {
    spawnKey();
  }

  

  // 6. Close any open popups/dialogue
  closeEndingPopup?.();
  closeVideoPopup?.();
}
/* -------------------------------------------------------------------  
   Main update loop (uses helpers above)  
   ------------------------------------------------------------------- */  
let last = performance.now(), spawnTimer = 0;  
function update(now){  
  const dt = Math.min(0.05, (now-last)/1000); last = now;  
  if (paused){ requestAnimationFrame(update); return; }  
    
  // ‚îÄ‚îÄ spawn animation update ‚îÄ‚îÄ  
if (player.spawning){  
  player.spawnTimer += dt;  
  if (player.spawnTimer >= player.spawnDuration){  
    player.spawnTimer = player.spawnDuration;  
    player.spawning = false;  
  }  
}  
  
  // keyboard fallback movement on foot  
  {  
    let mvx=0,mvy=0;  
    if (inputKeys['w']||inputKeys['arrowup']) mvy=-1;  
    if (inputKeys['s']||inputKeys['arrowdown']) mvy=1;  
    if (inputKeys['a']||inputKeys['arrowleft']) mvx=-1;  
    if (inputKeys['d']||inputKeys['arrowright']) mvx=1;  
    if (mvx||mvy){ input.moveX = mvx; input.moveY = mvy; }  
  }  
  
  const prevX = player.x;
  const prevY = player.y;

  // player movement on foot (safe move)  
if (!player.spawning){  
  const mag = Math.hypot(input.moveX, input.moveY);  
  
  if (mag > 0.15){  
    const speed = player.speed * (sprinting ? SPRINT_MULT : 1) * (inputKeys['shift'] ? player.runMult : 1);  
    const dx = (input.moveX / mag) * speed * dt;  
    const dy = (input.moveY / mag) * speed * dt;  
  
    if (!safeMove(player, dx, dy)){  
      // blocked  
    }  
  
    // üëÅÔ∏è ADD THIS ‚Äî update eye direction  
    player.lookX = input.moveX;  
    player.lookY = input.moveY;  
  }  
}   

for(const key of keys){
  if(!key.collected && Math.hypot(player.x - key.x, player.y - key.y) < 20){
    key.collected = true;
    // optional: play sound or show animation
    console.log("Key collected!", keys.filter(k => k.collected).length);
  }
}

const tx = Math.floor(player.x / TILE);
const ty = Math.floor(player.y / TILE);

// locked tiles
for (const lt of lockedTiles) {
  if (lt.opened) continue;
  if (tx === lt.x && ty === lt.y) {
    if (getCollectedKeyCount() >= lt.requiredKeys) {
      lt.opened = true;
      localStorage.setItem(SAVE_KEY, "true");
      console.log("Locked tile unlocked & saved!");

      // ‚úÖ Show minimap once unlocked
      document.getElementById("minimap").style.display = "block";
    } else {
      player.x = prevX;
      player.y = prevY;
    }
  }
}

// events
for(const e of eventTiles){
  if(!e.triggered && tx === e.x && ty === e.y){
    e.triggered = true;
    if(e.type==='image') showeventimg(e.data);
    if(e.type==='sound') new Audio(e.data).play();
  }
}

// ===== ENDING TILE (stand-on trigger every time) =====

if (tx === endingTile.x && ty === endingTile.y) {
  if (!endingPopupActive) {
    openEndingPopup();
    endingPopupActive = true;
  }
} else {
  endingPopupActive = false;
}

   // Cat
   const moving = Math.hypot(input.moveX, input.moveY) > 0.1;

if (moving) {
  idleTimer = 0;
  cat.circling = false;
} else {
  idleTimer += dt;
  if (idleTimer >= IDLE_TIME) {
    cat.circling = true;
  }
}

// cat 2
if (cat.circling) {
  // smooth transition into circle
  cat.angle += dt * (1.5 + Math.sin(performance.now() * 0.002));

  const baseRadius = 50;
  const wander = Math.sin(performance.now() * 0.003) * 6;

  const tx = player.x + Math.cos(cat.angle) * (baseRadius + wander);
  const ty = player.y + Math.sin(cat.angle) * (baseRadius + wander);

  // move towards circle target (no teleport)
  const dx = tx - cat.x;
  const dy = ty - cat.y;
  const dist = Math.hypot(dx, dy);

  if (dist > 0.5) {
    cat.x += (dx / dist) * 120 * dt;
    cat.y += (dy / dist) * 120 * dt;
  }
} else {
  // üêà adaptive follow
  const offsetDist = 36;
  const offsetAngle = Math.atan2(player.lookY, player.lookX) + Math.PI / 2;

  const targetX = player.x + Math.cos(offsetAngle) * offsetDist;
  const targetY = player.y + Math.sin(offsetAngle) * offsetDist;

  const dx = targetX - cat.x;
  const dy = targetY - cat.y;
  const dist = Math.hypot(dx, dy);

  // speed scales with distance
  const speed = Math.min(cat.baseSpeed + dist * 4, cat.maxSpeed);

  if (dist > 1) {
    cat.x += (dx / dist) * speed * dt;
    cat.y += (dy / dist) * speed * dt;
  }
}
    
// event tile check
let foundEvent = null;

for (const ev of eventTiles) {
  if (ev.x === tx && ev.y === ty) {
    foundEvent = ev;
    break;
  }
}

if (foundEvent) {
  // ENTER tile
  if (activeEventTile !== foundEvent) {
    activeEventTile = foundEvent;

    if (foundEvent.type === "image") {
      showeventimg(foundEvent.data);
    }

    if (foundEvent.type === "sound") {
      playEventSound(foundEvent.data);
    }
  }
} else {
  // LEAVE tile ‚Üí reset
  activeEventTile = null;
}

// ================= DIALOGUE ZONE CHECK =================  
{  
  const tx = Math.floor(player.x / TILE);  
  const ty = Math.floor(player.y / TILE);  
  
  let found = null;  
  
  for (const zone of dialogueZones){  
    for (const [zx, zy] of zone.tiles){  
      if (zx === tx && zy === ty){  
        found = zone;  
        break;  
      }  
    }  
    if (found) break;  
  }  
  
  if (found){  
    if (activeDialogueTile !== found){  
      activeDialogueTile = found;  
      dialogueText.textContent = found.text;  
      dialogueBox.classList.add("show");  
    }  
  } else {  
    if (activeDialogueTile){  
      activeDialogueTile = null;  
      dialogueBox.classList.remove("show");  
    }  
  }  
}  
  
  draw(); requestAnimationFrame(update);  
}    
  
/* -------------------------------------------------------------------  
   DRAWING (uses small helpers)  
   ------------------------------------------------------------------- */  
function drawTile(ctx,t,px,py,size){  
  if (t === 'water') ctx.fillStyle = '#1da3ff';  
  else if (t === 'park') ctx.fillStyle = '#58b25a';  
  else if (t === 'building') ctx.fillStyle = '#2f2f2f';  
  else ctx.fillStyle = '#bfbfbf';  
  ctx.fillRect(px,py,size,size);  
}  
  
function draw(){  
  ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);  
  // Smooth camera follow  
camX += (player.x - camX) * CAMERA_SPEED * 0.016; // 0.016 ‚âà 60fps  
camY += (player.y - camY) * CAMERA_SPEED * 0.016;  
  const vw = canvas.clientWidth, vh = canvas.clientHeight;  
  const startCol = Math.floor((camX - vw/2)/TILE) - 2;  
  const startRow = Math.floor((camY - vh/2)/TILE) - 2;  
  const cols = Math.ceil(vw/TILE) + 6, rows = Math.ceil(vh/TILE) + 6;  
  
  for (let r=0;r<rows;r++){  
    for (let c=0;c<cols;c++){  
      const tx = startCol + c, ty = startRow + r;  
      if (tx<0||ty<0||tx>=MAP_W||ty>=MAP_H) continue;  
      const t = world[ty][tx];  
      const px = tx*TILE - camX + vw/2, py = ty*TILE - camY + vh/2;  
      drawTile(ctx,t,px,py,TILE);  
    }  
  }  
  
    
  
  // ================= PLAYER DRAW =================  
const baseX = player.x - camX + canvas.clientWidth/2;  
const baseY = player.y - camY + canvas.clientHeight/2;  
  
ctx.save();  
  
if (player.spawning){  
    const p = player.spawnTimer / player.spawnDuration; // 0 ‚Üí 1  
  
    // Bounce: moves up/down  
    const bounce = Math.sin(p * Math.PI); // 0 ‚Üí 1 ‚Üí 0  
    const yOffset = -20 * (1 - bounce);  
  
    // Squash/Stretch  
    const scaleY = 0.7 + 0.3 * bounce; // vertical stretch  
    const scaleX = 1 + 0.2 * (1 - bounce); // horizontal squash  
  
    // Subtle rotation  
    const rot = (0.2 * (1 - bounce)) * (Math.random() < 0.5 ? -1 : 1);  
  
    ctx.translate(baseX, baseY + yOffset);  
    ctx.rotate(rot);  
    ctx.scale(scaleX, scaleY);  
    ctx.globalAlpha = p;  
} else {  
    ctx.translate(baseX, baseY);  
    ctx.globalAlpha = 1;  
}  
  
// ‚îÄ‚îÄ PLAYER BODY ‚îÄ‚îÄ  
ctx.fillStyle = '#E4D6F5';  
ctx.beginPath();  
ctx.arc(0, 0, player.r, 0, Math.PI * 2);  
ctx.fill();  
  
// ‚îÄ‚îÄ PLAYER EYES ‚îÄ‚îÄ  
const mag = Math.hypot(player.lookX, player.lookY) || 1;  
const lx = player.lookX / mag;  
const ly = player.lookY / mag;  
const eyeOffset = 6;  
const eyeSpread = 6;  
ctx.fillStyle = '#000';  
// left eye  
ctx.beginPath();  
ctx.arc(lx * eyeOffset - ly * eyeSpread, ly * eyeOffset + lx * eyeSpread, 2.2, 0, Math.PI * 2);  
ctx.fill();  
// right eye  
ctx.beginPath();  
ctx.arc(lx * eyeOffset + ly * eyeSpread, ly * eyeOffset - lx * eyeSpread, 2.2, 0, Math.PI * 2);  
ctx.fill();  
  
ctx.restore();  

for (const key of keys) {
  if (key.collected) continue;

  const kx = key.x - camX + canvas.clientWidth / 2;
  const ky = key.y - camY + canvas.clientHeight / 2;

  const t = performance.now();
  const float = Math.sin(t * 0.004) * 3;
  const shine = (Math.sin(t * 0.006) + 1) * 0.5;

  ctx.save();
  ctx.translate(kx, ky + float);
  ctx.rotate(Math.sin(t * 0.002) * 0.2);

  // key head
  ctx.fillStyle = `hsl(45, 90%, ${55 + shine * 15}%)`;
  ctx.beginPath();
  ctx.arc(0, 0, 7, 0, Math.PI * 2);
  ctx.fill();

  // hole
  ctx.fillStyle = '#d4a000';
  ctx.beginPath();
  ctx.arc(0, 0, 3, 0, Math.PI * 2);
  ctx.fill();

  // stem
  ctx.fillStyle = '#ffcc33';
  ctx.fillRect(6, -2, 12, 4);

  // tooth
  ctx.fillRect(14, -2, 3, 6);

  ctx.restore();
}


// === KEY COUNTER UI ===
const collected = getCollectedKeyCount();
const totalKeys = 5;

const uiX = canvas.width / 13;
const uiY = 25;

ctx.save();
ctx.font = '14px system-ui';
ctx.textAlign = 'center';

// background bubble
ctx.fillStyle = 'rgba(0,0,0,0.45)';
ctx.beginPath();
ctx.roundRect(uiX - 44, uiY - 14, 88, 26, 12);
ctx.fill();

// small key icon
ctx.fillStyle = '#ffcc33';
ctx.beginPath();
ctx.arc(uiX - 18, uiY, 6, 0, Math.PI * 2);
ctx.fill();
ctx.fillRect(uiX - 10, uiY - 2, 10, 4);

// text
ctx.fillStyle = '#fff';
ctx.fillText(`${collected} / ${totalKeys}`, uiX + 12, uiY + 4);

ctx.restore();


for(const lt of lockedTiles){
  const lx = (lt.x * TILE + TILE/2) - camX + canvas.clientWidth/2;
const ly = (lt.y * TILE + TILE/2) - camY + canvas.clientHeight/2;

  ctx.fillStyle = lt.opened ? '#6bff6b' : '#ff4c4c'; // green if open, red if locked
  ctx.fillRect(lx - TILE/2, ly - TILE/2, TILE, TILE);
  
  // optional: draw lock icon or text
  ctx.fillStyle = '#fff';
  ctx.font = '14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(lt.opened ? "OPEN" : "LOCKED", lx, ly + 5);
}

// ================= CAT DRAW (CHIBI STYLE) =================
const catX = cat.x - camX + canvas.clientWidth / 2;
const catY = cat.y - camY + canvas.clientHeight / 2;

ctx.save();
ctx.translate(catX, catY);

// gentle idle bounce
const t = performance.now();
const bob = Math.sin(t * 0.004) * 1.5;
ctx.translate(0, bob);

// ===== HEAD (big & round) =====
ctx.fillStyle = '#f8d7a4';
ctx.beginPath();
ctx.arc(0, -4, 8, 0, Math.PI * 2);
ctx.fill();

// ===== EARS (rounded, not pointy) =====
ctx.fillStyle = '#f3c58c';
ctx.beginPath();
ctx.arc(-5, -11, 3.2, 0, Math.PI * 2);
ctx.arc(5, -11, 3.2, 0, Math.PI * 2);
ctx.fill();

// ===== BODY (tiny) =====
ctx.fillStyle = '#f1c88e';
ctx.beginPath();
ctx.ellipse(0, 6, 5, 3.8, 0, 0, Math.PI * 2);
ctx.fill();

// ===== FACE =====
ctx.fillStyle = '#000';

// eyes (big dot style)
ctx.beginPath();
ctx.arc(-3, -5, 1.4, 0, Math.PI * 2);
ctx.arc(3, -5, 1.4, 0, Math.PI * 2);
ctx.fill();

// mouth (tiny Àò)
ctx.strokeStyle = '#000';
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(-1.2, -2.5);
ctx.quadraticCurveTo(0, -1.5, 1.2, -2.5);
ctx.stroke();

// ===== TAIL (important for cat feel) =====
const tailWave = Math.sin(t * 0.008) * 4;
ctx.strokeStyle = '#eabf84';
ctx.lineWidth = 2.2;
ctx.beginPath();
ctx.moveTo(6, 7);
ctx.quadraticCurveTo(12, 5 + tailWave * 0.3, 10, -1 + tailWave);
ctx.stroke();

ctx.restore();
  
    
  
  drawMinimap();  
}  
  
/* minimap and fullmap re-use drawTile color map */  
function drawMinimap(){  
  mctx.clearRect(0,0,mini.clientWidth,mini.clientHeight);  
  const TILE_VIEW = 10;  
  const tileW = mini.clientWidth / TILE_VIEW;  
  const tileH = mini.clientHeight / TILE_VIEW;  
  const centerX = mini.clientWidth/2, centerY = mini.clientHeight/2;  
  const pTileX = player.x / TILE, pTileY = player.y / TILE;  
  const startTileX = Math.floor(pTileX - TILE_VIEW/2), startTileY = Math.floor(pTileY - TILE_VIEW/2);  
  
  for (let y=0;y<TILE_VIEW;y++){  
    for (let x=0;x<TILE_VIEW;x++){  
      const tx = startTileX + x, ty = startTileY + y;  
      if (tx<0||ty<0||tx>=MAP_W||ty>=MAP_H) continue;  
      const t = world[ty][tx];  
      let color;  
      if (t==='water') color='#1da3ff'; else if (t==='park') color='#3aa84f'; else if (t==='building') color='#404040'; else color='#bfbfbf';  
      mctx.fillStyle = color;  
      const dx = (tx - pTileX) * tileW, dy = (ty - pTileY) * tileH;  
      mctx.fillRect(centerX + dx, centerY + dy, tileW, tileH);  
    }  
  }  
  // player marker  
  mctx.fillStyle='#00ff00'; mctx.fillRect(centerX-2,centerY-2,4,4);  
     
}  
  
/* map popup */  
mini.addEventListener('click', ()=>{ mapPopup.style.display='flex'; drawFullMap(); });  
mapPopup.addEventListener('click', ()=> mapPopup.style.display='none');  
function drawFullMap(){  
  bctx.clearRect(0,0,bigMapCanvas.width,bigMapCanvas.height);  
  const w = bigMapCanvas.width / MAP_W, h = bigMapCanvas.height / MAP_H;  
  for (let y=0;y<MAP_H;y++){  
    for (let x=0;x<MAP_W;x++){  
      const t=world[y][x];  
      if(t==='water') bctx.fillStyle='#1da3ff';  
      else if(t==='park') bctx.fillStyle='#3aa84f';  
      else if(t==='building') bctx.fillStyle='#404040';  
      else bctx.fillStyle='#bfbfbf';  
      bctx.fillRect(x*w, y*h, w, h);  
    }  
  }  
  bctx.fillStyle='#00ff00'; bctx.fillRect(player.x/TILE*w-2, player.y/TILE*h-2, 4,4);  
}  
  
/* -------------------------------------------------------------------  
   start  
   ------------------------------------------------------------------- */  
last = performance.now(); const openingScreen = document.getElementById("openingScreen");

startBtn.addEventListener("click", () => {
  openingScreen.style.display = "none";   // hide popup
  const music = document.getElementById("bgMusic");
  music.volume = 0.3;                      // optional: set volume
  music.play();                             // start music
  requestAnimationFrame(update);            // start game loop
});
</script>  </body>  
</html>
